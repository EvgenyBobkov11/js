TypeScript является строго типизированным языком, и каждая переменная и константа в нем имеет определенный тип. При этом в отличие от javascript мы не можем динамически изменить ранее указанный тип переменной.

В TypeScript имеются следующие базовые типы:

Boolean: логическое значение true или false

Number: числовое значение

String: строки

Array: массивы

Tuple: кортежи

Enum: перечисления

Any: произвольный тип

Null и undefined: соответствуют значениям null и undefined в javascript

Void: отсутствие конкретного значения, используется в основном в качестве возвращаемого типа функций

Never: также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку

Большинство из этих типов соотносятся с примитивными типами из JavaScript.

Для установки типа применяется знак двоеточия. Примеры создания переменных:


let x: number = 10; 
let hello: string = "hello world";
let isValid: boolean = true;
То есть в данном случае выражение let hello: string = "hello world" указывает, что переменная hello будет иметь тип string и значение hello world.

При этом если в коде мы потом захотим изменить тип, например:


let hello: string = "hello world";
hello = 23;
То в процессе компиляции компилятор TypeScript выдаст ошибку, и мы попросту не сможем запустить программу.

Но можно в принципе и не указывать тип переменной. Например:


let hello = "hello world";
hello = 23;
В этом случае TypeScript автоматически выведет тип из присваемого данной переменной значения. Так, на первой строке компилятор TS увидит, что переменной присваивается строка, поэтому для нее будет использоваться тип string. Однако на второй строке опять же компилятор выдаст ошибку, поскольку у переменной уже определен тип string. А новое значение предполагает тип number.

Если же переменная определяется без значения, и только впоследствии при работе программы ей присваивается значение, тогда считается, что она имеет тип any:


let x;  // тип any
x = 10; 
Boolean
Тип Boolean представляет логическое значение true или false:


let isEnabled = true;
let isAlive: boolean = false;
 
console.log(isEnabled);
console.log(isAlive);
Number
Тип Number представляет числа, причем все числа в TypeScript, как и в JavaScript, являются числами с плавающей точкой. TS поддерживает двоичную, восьмеричную, десятичную и шестнадцатиричную записи чисел:


let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
String
String представляет строки. Как и в JavaScript, в TypeScript строки можно заключать в двойные, либо в одинарные кавычки:


let firstName: string = "Tom";
let lastName = 'Johns';
Кроме того, TypeScript поддерживает такую функциональность, как шаблоны строк, то есть мы можем задать шаблон в косых кавычках (`), как если бы мы писали обычную строку, и затем в саму строку можно встраивать разные выражения с помощью синтаксиса ${ expr }, где expr - это выражение. Например:


let firstName: string = "Tom";
let age: number = 28;
let info: string = `Имя ${firstName}    Возраст: ${age}`;
console.log(info);  // Имя Tom    Возраст: 28
Косые кавычки также можно применять для установки многострочного текста:


let sentence: string = `Hello World!
Goob bye World!`;
Null и undefined
Как и в JavaScript, в TypeScript есть специальные типы undefined и null, которые принимают соответствующие значения undefined и null:


let a: undefined = undefined;
let b: null = null;
Но фактически мы можем присваивать значения undefined и null переменным других типов, например, number:


let x: number = undefined;
console.log(x);
x = null;
console.log(x);
x = 5;
console.log(x);
В этом плане null и undefined выступают как подтипы других типов и полезны преимущественно в каких-то операциях, где неизвестен результат - то ли это будет число или строка, то ли это будет null. В этом случае, чтобы избежать возможной ошибки, мы можем проверить значение на undefined или null, собственно как и в javascript.

Массивы
Массивы определяются с помощью выражения [] и также являются строго типизированными. То есть если изначально массив содержит строки, то в будущем он сможет работать только со строками.


let list: number[] = [10, 20, 30];
let colors: string[] = ["red", "green", "blue"];
console.log(list[0]);
console.log(colors[1]);
Как и в JavaScript, с помощью индексов можно обращаться к элементам массива.

Альтернативный способ определения массивов представляет применение типа Array<>:


let names: Array<string> = ["Tom", "Bob", "Alice"];
console.log(names[1]);  // Bob
Кортежи
Кортежи (Tuples) также, как и массивы, представляют набор элементов, для которых уже заранее известен тип. Например:


// определение кортежа - кортеж состоит из двух элементов - строки и числа
let userInfo: [string, number];
// инициализация кортежа
userInfo = ["Tom", 28];
// Неправильная инициализация - переданные значения не соответствуют типам по позиции
//userInfo = [28, "Tom"]; // Ошибка
 
// использование кортежа
console.log(userInfo[1]); // 28
userInfo[1] = 37;
Тип enum
Тип enum предназначен для описания набора числовых данных с помощью строковых констант. Так, объявим следующее перечисление:


enum Season { Winter, Spring, Summer, Autumn };
Перечисление называется Season и имеет четыре элемента. Теперь используем перечисление:


enum Season { Winter, Spring, Summer, Autumn };
let current: Season = Season.Summer;
console.log(current);
current = Season.Autumn; // изменение значения
Здесь создается переменная current, которая имеет тип Season. При этом консоль выведет нам число 2. Так как все элементы перечисления представляют числовые значения. По умолчанию следующие:


enum Season { Winter=0, Spring=1, Summer=2, Autumn=3 };
Хотя мы можем переопределить эти значения:

enum Season { Winter=5, Spring, Summer, Autumn };           // 5, 6, 7, 8
enum Season { Winter=4, Spring=8, Summer=16, Autumn=32 };   // 4, 8, 16, 32
Также мы можем получить непосредственно текстовое значение:


enum Season { Winter=0, Spring=1, Summer=2, Autumn=3 };
var current: string = Season[2];    // 2 - числовое значение Summer
console.log(current);   // Summer
Тип any
Any описывает данные, тип которых может быть неизвестен на момент написания приложения.


let someVar: any = "hello";
console.log(someVar);   // сейчас someVar - это string
someVar = 20; 
console.log(someVar);   // сейчас someVar - это number
Так как здесь применяется тип any, то данный код скомпилируется без ошибок, несмотря на смену строкового значения на числовое. И также мы можем объявлять массивы данного типа:


var someArray: any[] = [ 24, "Tom", false];
Комплексные объекты
Кроме простых переменных, как и в javascript, можно создавать сложные объекты. Например:


let person = {name:"Tom", age:23};
console.log(person.name);
// альтернативный вариант получения свойства
console.log(person["name"]);
Но несмотря на то, что это фактически тот же самый объект, что мы могли бы использовать в JavaScript, в силу строготипизированности TS мы имеем в данном случае ограничения. В частности, если у нас будет следующий код:


let person = { name: "Tom", age: 23 };
person = { name: "Alice" };
То на второй строке мы получим ошибку, поскольку компилятор после первой строки предполагает, что объект person будет иметь два свойства name и age. Должно быть соответствие по названиям, количеству и типу свойств.


Новый материал

Объединения
Объединения или union не являются собственно типом данных, но они позволяют определить переменную, которая может хранить значение двух или более типов:


let id : number | string;
id = "1345dgg5";
console.log(id); // 1345dgg5
id = 234;
console.log(id);  // 234
Чтобы определить все типы, которые должно представлять перечисление, все эти типы разделяются прямой чертой: number | string. В данном случае переменная id может представлять как тип string, то есть строку, так и число.

Проверка типа
С помощью оператора typeof мы можем проверить тип переменной. Это может быть необходимо, когда мы хотим выполнить некоторые операции с переменной, но нам неизвестен ее точный тип (например, переменная представляет тип any). Данная функциональность еще называется type guards или защита типа:

let sum: any;
sum = 1200;
sum = "тысяча двести";
let result: number = sum / 12;
console.log(result); // NaN - строку нельзя разделить на число
Переменная sum может хранит любое значение, однако деление может работать только с числами. Поэтому перед делением выполним проверку на тип:


let sum: any;
sum = 1200;
 
if (typeof sum === "number") {
     
    let result: number = sum / 12;
    console.log(result);
}
else{
    console.log("invalid operation");
}
Оператор typeof возвращает тип значения. Например, выражение typeof sum в данном случае возращает "number", так как переменная sum представляет число.

Псевдонимы типов
TypeScript позволяет определять псевдонимы типов с помощью ключевого слова type:


type stringOrNumberType = number | string;
let sum: stringOrNumberType = 36.6;
if (typeof sum === "number") {
    console.log(sum / 6);
}
Далее мы сможем применять псевдоним аналогично типу данных.

Type assertion
Type assertion представляет модель преобразования значения переменной к определенному типу. Обычно в некоторых ситуациях одна переменная может представлять какой-то широкий тип, например, any, который по факту допускает значения различных типов. Однако при этом нам надо использовать переменную как значение строго определенного типа. И в этом случае мы можем привести к этому типу.

Есть две формы приведения. Первая форма заключается в использовании угловых скобок:


let someAnyValue: any = "hello world!";
let strLength: number = (<string>someAnyValue).length;
console.log(strLength); // 12
 
let someUnionValue: string | number = "hello work";
strLength = (<string>someUnionValue).length;
console.log(strLength); // 10
Вторая форма заключается в применении оператора as:


let someAnyValue: any = "hello world!";
let strLength: number = (someAnyValue as string).length;
console.log(strLength); // 12
 
let someUnionValue: string | number = "hello work";
strLength = (someUnionValue as string).length;
console.log(strLength); // 10

Определение функции
В javascript функции определяются с помощью ключевого слова function, например:

1
2
3
4
5
6
function add(a, b) {
    return a + b;
}
// использование функции
var result1 = add(1, 2); // результат 3
var result2 = add("1", "2"); // результат 12
TypeScript также определяет функцию с помощью ключевого слова function, но при этом добавляет дополнительные возможности по работе с функциями. В частности, теперь мы можем определить тип передаваемых параметров и тип возвращаемого значения. Типичное определение функции в TypeScript:


// определение функции
function add(a: number, b: number): number {
    return a + b;
}
// вызов функции
let result1 = add(1, 2);
console.log(result1);
Либо мы можем опредить функцию как переменную и затем через переменной вызывать данную функцию:


let add = function (a: number, b: number) : number {
    return a + b;
}
let result1 = add(1, 2);
Параметры функции
Функция может иметь параметры, которые указываются после названия функции в скобках через запятую. Через двоеточие после имени параметра указывается его тип:


// определение функции
function add(a: number, b: number){
    let result = a + b;
    console.log(result);
}
// вызов функции
add(20, 30); // 50
add(10, 15); //25
Однако поскольку параметры имеют тип number, то при вызове функции


add("1", "2");
компилятор TS выдаст ошибку, так как параметры должны иметь тип number, а не тип string.

При этом функция может не только использовать передаваемые параметры, но и глобальные переменные, определенные во вне:


let koef: number = 1.5;
 
function add(a: number){
    let result = a *koef;
    console.log(result);
}
 
add(20); // 30
add(10); //15
Результат функции
Функция может возвращать значение определенного типа, который еще называется типом функции. Возвращаемый тип функции ставится после списка параметров через двоеточие:


function add(a: number, b: number): number {
    return a + b;
}
let result1 = add(1, 2);
В данном случае функция будет возвращать значение типа number.

Если функция ничего не возвращает, то указывается тип void:


function add(a: number, b: number): void {
    console.log(a + b);
}
add(10, 20);
В принципе мы можем и не указывать тип, тогда он будет выводиться неявно на основе возвращаемого значения:


function add(a: number, b: number) {
    return a + b;
}
let result = add(10, 20);
Необязательные параметры
В typescript при вызове в функцию должно передаваться ровно столько значений, сколько в ней определено параметров:


function getName(firstName: string, lastName: string) {
    return firstName + " " + lastName;
}
 
let name1 = getName("Иван", "Кузнецов");
let name2 = getName("Иван", "Михайлович", "Кузнецов");  //ошибка, много параметров
let name3 = getName("Иван");  //ошибка, мало параметров
Чтобы иметь возможность передавать различное число значений в функцию, в TS некоторые параметры можно объявить как необязательные. Необязательные параметры должны быть помечены вопросительным знаком ?. Причем необязательные параметры должны идти после обязательных:


function getName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
}
  
let name1 = getName("Иван", "Кузнецов");
console.log(name1); // Иван Кузнецов
let name2 = getName("Вася");
console.log(name2); // Вася
Во втором случае, когда в функцию передается только имя, второй используемый параметр будет иметь неопределенное значение или "undefined". Поэтому с помощью условной конструкции проверяется наличие значения для этого параметра.

Значения параметров по умолчанию
Параметры позволяют задать начальное значение по умолчанию. И если для такого параметра не передается значение, то он использует значение по умолчанию:


function getName(firstName: string, lastName: string="Иванов") {
     
    return firstName + " " + lastName;
}
 
let name1 = getName("Иван", "Кузнецов");
console.log(name1); // Иван Кузнецов
let name2 = getName("Вася");
console.log(name2); // Вася Иванов
Причем в качестве значения можно передавать результат другого выражения:


function defaultSurname(): string{
    return "Smith";
}
 
function getName(firstName: string, lastName: string=defaultSurname()) {
     
    return firstName + " " + lastName;
}
 
let name1 = getName("Tom");
console.log(name1); // Tom Smith
Неопределенный набор параметров
Если же необходимо, чтобы функция принимала набор однотипных параметров, то используется знак многоточия, после которого идет массив:


function addNumbers(firstNumber: number, ...numberArray: number[]): number {
      
    let result = firstNumber;
    for (let i = 0; i < numberArray.length; i++) {
        result+= numberArray[i];
    }
    return result;
}
  
let num1 = addNumbers(3, 7, 8);
console.log(num1); // 18
  
let num2 = addNumbers(3, 7, 8, 9, 4);
console.log(num2); // 31
Перегрузка функций
TypeScript поддерживает возможность перегрузки функций, то есть мы можем определить несколько версий функции, которые будут иметь одно и то же имя, но разные типы параметров или разное количество параметров. Для перегрузки вначале опеределяем все версии функции, которые не будут иметь никакой логики. А потом определяем версию функции с общей сигнатурой, которая подходит под все ранее определенные варианты. И в этой общей версии уже определяем конкретную логику функции.

Например, нам надо объединить два значения, но если они представляют строки, то просто их конкатенировать, а если числа - то сложить. Тогда мы могли бы использовать следующую функцию:


function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: any, y: any): any {
    return x + y;
}
 
let result1 = add(5, 4);
console.log(result1);   // 9
let result2 = add("5", "4");
console.log(result2);   // 54
Первая версия функции add принимает две строки и возвращает строку, вторая версия принимает два числа и возвращает число. Общей для них будет функция, которая принимает параметры типа any и возвращает результат также типа any.

Но если бы мы ту же функцию применили бы к логическим значениям:


let result3 = add(true, false);
console.log(result3);
то мы получили бы ошибку, так как две версии функции позволяют принимать в качестве параметров либо две строки, либо два числа. И в этом случае нам надо было бы добавить еще одну версию функции для логических значений:


function add(x: boolean, y: boolean): boolean;


Тип функции
Каждая функция имеет тип, как и обычные переменные. Тип функции фактически представляет комбинацию типов параметров и типа возвращаемого значения. Например, возьмем следующую функцию:


function sum (x: number, y: number): number {
    return x + y;
};
Она имеет тип (x:number, y:number) => number;, то есть принимает два параметра number и возвращает значение типа number. Названия параметров в типе функции необязательно должны соответствовать названиям конкретной функции. А перед типом возвращаемого значения ставится знак равно со стрелкой.

И подобно тому, как определяются переменные определенного типа, можно определять переменные, которые имеют тип функции:

1
let op: (x:number, y:number) => number;
То есть переменная op представляет любую функцию, которая принимает два числа и которая возвращает число. Например:


function sum (x: number, y: number): number {
    return x + y;
};
function subtract (a: number, b: number): number {
    return a - b;
};
 
let op: (x:number, y:number) => number;
 
op = sum;
console.log(op(2, 4));  // 6
 
op = subtract;
console.log(op(6, 4));  // 2
Здесь вначале переменная op указывает на функцию sum. И соответственно вызов op(2, 4) фактически будет представлять вызов sum(2, 4). А затем op указывает на функцию subtract.

Функции обратного вызова
Тип функции можно использовать как тип переменной, но он также может применяться для определения типа параметра другой функции:


function mathOp(x: number, y: number, operation: (a: number, b: number) => number): number{
 
    let result = operation(x, y);
    return result;
}
let operationFunc: (x: number, y: number) => number;
operationFunc = function (a: number, b: number): number {
    return a + b;
}
console.log(mathOp(10, 20, operationFunc)); // 30 
 
operationFunc = function (a: number, b: number): number {
    return a * b;
}
console.log(mathOp(10, 20, operationFunc)); // 200 
Здесь в функции mathOp третий парметр как раз представляет функцию, которая принимает два параметра типа number и возвращает число. Фактически тем самым мы можем передавать функции обратного вызова, например, при генерации событий, когда в ответ на некоторое действие срабатывает другая функция.

Стрелочные функции
Для определения функций в TypeScript можно использовать стрелочные функции или arrow functions. Стрелочные функции представляют выражения типа (параметры) => тело функции. Например:


let sum = (x: number, y: number) => x + y;
 
let result = sum(15, 35); // 50
console.log(result);
Тип параметров можно опускать:


let sum = (x, y) => x + y;
  
let result = sum(15, 35); // 50
console.log(result);
Если стрелочная функция не требует параметров, то используются пустые круглые скобки. Если передается только один параметр, то скобки можно опустить:


let square = x => x * x;
let hello = () => "hello world"
  
console.log(square(5)); // 25
console.log(hello());   // hello world
Если тело функции представляет множество выражений, а не просто одно выражение, как в примере выше, тогда можно опять же заключить все выражения в фигурные скобки:


let sum = (x: number, y: number) => {
    x *= 2;
    return x + y;
};
 
let result = sum(15, 35); // 65
console.log(result);
Стрелочные функции можно передавать в функцию вместо параметра, который представляет собой функцию:


function mathOp(x: number, y: number, operation: (a: number, b: number) => number): number{
 
    let result = operation(x, y);
    return result;
}
console.log(mathOp(10, 20, (x,y)=>x+y)); // 30 
console.log(mathOp(10, 20, (x, y) => x * y)); // 200 